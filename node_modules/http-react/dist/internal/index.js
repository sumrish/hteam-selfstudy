'use client';
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useHRFContext = exports.FetchContext = exports.requestsProvider = exports.defaultCache = exports.urls = exports.runningMutate = exports.cacheForMutation = exports.fetcherDefaults = exports.suspenseInitialized = exports.hasErrors = exports.maxPaginationAges = exports.suspenseRevalidationStarted = exports.requestEnds = exports.requestStarts = exports.requestResponseTimes = exports.requestInitialTimes = exports.canDebounce = exports.abortControllers = exports.resolvedOnErrorCalls = exports.resolvedHookCalls = exports.resolvedRequests = exports.willSuspend = exports.maxAges = exports.pageStarted = exports.hasData = exports.offlineHandled = exports.onlineHandled = exports.valuesMemory = exports.previousProps = exports.previousConfig = exports.lastResponses = exports.statusCodes = exports.isPending = exports.runningRequests = void 0;
var react_1 = require("react");
var constants_1 = require("./constants");
/**
 * This marks which requests are running
 */
exports.runningRequests = {};
function isPending(id) {
    return exports.runningRequests[id];
}
exports.isPending = isPending;
exports.statusCodes = {};
exports.lastResponses = {};
/**
 * Previous request configurations (useful for deduplication)
 */
exports.previousConfig = {};
exports.previousProps = {};
exports.valuesMemory = {};
/**
 * Online / offline
 */
exports.onlineHandled = {};
exports.offlineHandled = {};
/**
 * To let know if it's revalidating there is at least one succesful request
 */
exports.hasData = {};
/**
 * Max pagination age
 */
exports.pageStarted = {};
exports.maxAges = {};
/**
 * For Suspense
 */
exports.willSuspend = {};
exports.resolvedRequests = {};
exports.resolvedHookCalls = {};
exports.resolvedOnErrorCalls = {};
exports.abortControllers = {};
exports.canDebounce = {};
exports.requestInitialTimes = {};
exports.requestResponseTimes = {};
exports.requestStarts = {};
exports.requestEnds = {};
exports.suspenseRevalidationStarted = {};
exports.maxPaginationAges = {};
/**
 * Request with errors
 */
exports.hasErrors = {};
/**
 * Suspense calls that resolved
 */
exports.suspenseInitialized = {};
/**
 * Defaults used as fallback data (works with SSR)
 */
exports.fetcherDefaults = {};
exports.cacheForMutation = {};
exports.runningMutate = {};
exports.urls = {};
/**
 * Default store cache
 */
exports.defaultCache = {
    get: function (k) {
        return exports.resolvedRequests[k];
    },
    set: function (k, v) {
        exports.resolvedRequests[k] = v;
    },
    remove: function (k) {
        delete exports.resolvedRequests[k];
    }
};
var requestsSubscribers = {};
exports.requestsProvider = {
    addListener: function (requestId, listener) {
        if (!requestsSubscribers[requestId]) {
            requestsSubscribers[requestId] = [];
        }
        requestsSubscribers[requestId].push(listener);
    },
    removeListener: function (requestId, listener) {
        if (!requestsSubscribers[requestId]) {
            requestsSubscribers[requestId] = [];
        }
        requestsSubscribers[requestId] = requestsSubscribers[requestId].filter(function (l) { return l !== listener; });
    },
    emit: function (requestId, payload) {
        if (requestsSubscribers[requestId]) {
            requestsSubscribers[requestId].forEach(function (listener) {
                listener(payload);
            });
        }
    }
};
var defaultContextVaue = {
    defaults: constants_1.DEFAULTS,
    attempts: constants_1.ATTEMPTS,
    attemptInterval: constants_1.ATTEMPT_INTERVAL,
    revalidateOnFocus: constants_1.REVALIDATE_ON_FOCUS,
    query: constants_1.QUERY,
    params: constants_1.PARAMS,
    onOffline: constants_1.ON_OFFLINE,
    onOnline: constants_1.ON_ONLINE,
    online: constants_1.ONLINE,
    retryOnReconnect: constants_1.RETRY_ON_RECONNECT,
    revalidateOnMount: constants_1.REVALIDATE_ON_MOUNT,
    cacheIfError: true
};
exports.FetchContext = (0, react_1.createContext)(defaultContextVaue);
function useHRFContext() {
    return (0, react_1.useContext)(exports.FetchContext);
}
exports.useHRFContext = useHRFContext;
