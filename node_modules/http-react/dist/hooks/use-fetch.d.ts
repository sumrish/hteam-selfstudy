import { CustomResponse, FetchConfigType, FetchConfigTypeNoUrl, HTTP_METHODS, ImperativeFetch, TimeSpan } from '../types';
/**
 * Fetch hook
 */
export declare function useFetch<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string | Request, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    /**
     * Revalidating means that at least one request has finished succesfuly and a new request is being sent
     */
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: import("../types").FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: import("../types").FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
export declare namespace useFetch {
    export var get: import("../types").RequestWithBody;
    var _a: import("../types").RequestWithBody;
    export var head: import("../types").RequestWithBody;
    export var options: import("../types").RequestWithBody;
    export var post: import("../types").RequestWithBody;
    export var put: import("../types").RequestWithBody;
    export var patch: import("../types").RequestWithBody;
    export var purge: import("../types").RequestWithBody;
    export var link: import("../types").RequestWithBody;
    export var unlink: import("../types").RequestWithBody;
    export var extend: (ctx: import("../types").FetchContextType) => ImperativeFetch;
    export { _a as delete };
}
