import { FetchConfigType, FetchConfigTypeNoUrl, FetchContextType, ImperativeFetch, TimeSpan } from '../types';
/**
 * Get the current fetcher config
 */
export declare function useFetchConfig(id?: unknown): Omit<RequestInit, "body" | "headers"> & {
    headers?: any;
    fetcher?(url: string, config: FetchConfigType<any, any>): Promise<{
        json?: any;
        data?: any;
        status?: number | undefined;
        blob?: any;
        text?: any;
    }>;
    body?: any;
    id?: any;
    url?: string | undefined;
    default?: any;
    refresh?: TimeSpan | undefined;
    auto?: boolean | undefined;
    memory?: boolean | undefined;
    onResolve?: ((data: any, res?: Response | undefined) => void) | undefined;
    cacheProvider?: import("../types").CacheStoreType | undefined;
    onMutate?: ((data: any, fetcher: ImperativeFetch) => void) | undefined;
    onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
    onAbort?: (() => void) | undefined;
    cancelOnChange?: boolean | undefined;
    resolver?: ((d: import("../types").CustomResponse<any>) => any) | undefined;
    attempts?: number | undefined;
    attemptInterval?: TimeSpan | undefined;
    revalidateOnFocus?: boolean | undefined;
    revalidateOnMount?: boolean | undefined;
    onOffline?: (() => void) | undefined;
    onOnline?: ((e: {
        cancel: () => void;
    }) => void) | undefined;
    retryOnReconnect?: boolean | undefined;
    suspense?: boolean | undefined;
    baseUrl?: string | undefined;
    method?: import("../types").HTTP_METHODS | undefined;
    query?: any;
    params?: any;
    formatBody?: boolean | ((b: any) => any) | undefined;
    debounce?: TimeSpan | undefined;
    onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
    onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
    cacheIfError?: boolean | undefined;
    maxCacheAge?: TimeSpan | undefined;
} & {
    fetcher?(url: string, config: FetchConfigType<any, any>): Promise<{
        json?: any;
        data?: any;
        status?: number | undefined;
        blob?: any;
        text?: any;
    }>;
    headers?: any;
    baseUrl?: string | undefined;
    defaults?: {
        [key: string]: {
            id?: any;
            value?: any;
            method?: import("../types").HTTP_METHODS | undefined;
        };
    } | undefined;
    suspense?: any[] | undefined;
    resolver?: ((r: Response) => any) | undefined;
    children?: any;
    auto?: boolean | undefined;
    memory?: boolean | undefined;
    refresh?: TimeSpan | undefined;
    attempts?: number | undefined;
    attemptInterval?: TimeSpan | undefined;
    revalidateOnFocus?: boolean | undefined;
    query?: any;
    params?: any;
    onOnline?: ((e: {
        cancel: () => void;
    }) => void) | undefined;
    onOffline?: (() => void) | undefined;
    online?: boolean | undefined;
    retryOnReconnect?: boolean | undefined;
    cacheProvider?: import("../types").CacheStoreType | undefined;
    revalidateOnMount?: boolean | undefined;
    cacheIfError?: boolean | undefined;
    onFetchStart?(req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType): void;
    onFetchEnd?(res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType): void;
    maxCacheAge?: TimeSpan | undefined;
} & Omit<RequestInit, "body">;
export declare function useFetchSuspense<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Get the data state of a request using its id
 */
export declare function useFetchData<ResponseType = any, VT = any>(id: ResponseType extends {
    value: ResponseType;
    variables: VT;
    errors?: any[];
} ? {
    value: ResponseType;
    variables: VT;
    errors?: any[];
} : string | number | object, onResolve?: (data: typeof id extends {
    variables: any;
} ? {
    data: (Required<typeof id> & {
        value: ResponseType;
        variables: VT;
    })['value'];
    variables: (Required<typeof id> & {
        value: ResponseType;
        variables: VT;
    })['variables'];
} : ResponseType, res: Response) => void): ResponseType;
export declare function useFetchCode(id: any): number;
/**
 * Get the loading state of a request using its id
 */
export declare function useFetchLoading(id: any): boolean;
/**
 * Get the error state of a request using its id
 */
export declare function useFetchError(id: any, onError?: (err?: any) => void): any;
/**
 * Get the mutate the request data using its id
 */
export declare function useFetchMutate<T = any>(
/**
 * The id of the `useFetch` call
 */
id: any, 
/**
 * The function to run after mutating
 */
onMutate?: (data: T, 
/**
 * An imperative version of `useFetch`
 */
fetcher: ImperativeFetch) => void): (update: T | ((prev: T) => T), callback?: ((data: T, fetcher: ImperativeFetch) => void) | undefined) => T;
export declare function useOnline(id: any): boolean;
export declare function useLoadingFirst(id: any): boolean;
export declare function useReFetch(id: any): () => Promise<void>;
export declare function useRevalidating(id: any): boolean;
export declare function useExpiration(id: any): Date;
export declare function useHasData(id: any): boolean;
export declare function useSuccess(id: any): boolean;
/**
 * Get everything from a `useFetch` call using its id
 */
export declare function useFetchId<ResponseType = any, BodyType = any>(id: any): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: ResponseType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: ResponseType | ((prev: ResponseType) => ResponseType), callback?: ((data: ResponseType, fetcher: ImperativeFetch) => void) | undefined) => ResponseType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<ResponseType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: ResponseType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: ResponseType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: ResponseType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<ResponseType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<ResponseType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Create an effect for when the request completes
 */
export declare function useResolve<ResponseType = any, VT = any>(id: ResponseType extends {
    variables: any;
} ? string | number | object : {
    value: ResponseType;
    variables: VT;
    errors?: any[];
}, onResolve: (data: typeof id extends {
    variables: any;
} ? {
    data: (Required<typeof id> & {
        value: ResponseType;
    })['value'];
    variables: (Required<typeof id> & {
        variables: VT;
    })['variables'];
    errors: (Required<typeof id> & {
        errors?: any[];
    })['errors'];
} : ResponseType, res: Response) => void): any;
/**
 * User a `GET` request
 */
export declare function useGET<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Use a `DELETE` request
 */
export declare function useDELETE<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Use a `HEAD` request
 */
export declare function useHEAD<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Use an `OPTIONS` request
 */
export declare function useOPTIONS<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Use a `POST` request
 */
export declare function usePOST<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Use a `PUT` request
 */
export declare function usePUT<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Use a `PATCH` request
 */
export declare function usePATCH<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Use a `PURGE` request
 */
export declare function usePURGE<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Use a `LINK` request
 */
export declare function useLINK<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Use an `UNLINK` request
 */
export declare function useUNLINK<FetchDataType = any, BodyType = any>(init: FetchConfigType<FetchDataType, BodyType> | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Get a blob of the response. You can pass an `objectURL` property that will convet that blob into a string using `URL.createObjectURL`
 */
export declare function useFetchBlob<FetchDataType = string, BodyType = any>(init: (FetchConfigType<FetchDataType, BodyType> & {
    objectURL?: boolean;
}) | string, options?: FetchConfigTypeNoUrl<FetchDataType, BodyType> & {
    objectURL?: boolean;
}): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Get a text of the response
 */
export declare function useFetchText<FetchDataType = string, BodyType = any>(init: FetchConfigType<string, BodyType> | string, options?: FetchConfigTypeNoUrl<string, BodyType>): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: string;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: string | ((prev: string) => string), callback?: ((data: string, fetcher: ImperativeFetch) => void) | undefined) => string;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<string, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: string | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: string, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: string, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<string>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<string>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
export declare function useFetchResponseTime(id: any): number;
/**
 * Get the `Date` the request started
 */
export declare function useRequestStart(id: any): Date;
/**
 * Get the `Date` the request finished
 */
export declare function useRequestEnd(id: any): Date;
/**
 * Debounce a fetch by the time given
 */
export declare function useDebounceFetch<FetchDataType = any, BodyType = any>(init: (Omit<FetchConfigType<FetchDataType, BodyType>, 'debounce'> & {
    debounce?: TimeSpan;
}) | string | Request, options?: Omit<FetchConfigTypeNoUrl<FetchDataType, BodyType>, 'debounce'> & {
    debounce?: TimeSpan;
}): {
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: FetchDataType;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: FetchDataType | ((prev: FetchDataType) => FetchDataType), callback?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined) => FetchDataType;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<FetchDataType, BodyType>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: BodyType | undefined;
        id?: any;
        url?: string | undefined;
        default?: FetchDataType | undefined;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: FetchDataType, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: FetchDataType, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<FetchDataType>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: BodyType) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<FetchDataType>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
};
/**
 * Make a graphQL request
 */
export declare function useGql<T = any, VT = {
    [k: string]: any;
}>(arg1: undefined | {
    value: T;
    variables: VT;
}, cfg?: FetchConfigTypeNoUrl<T, any> & {
    /**
     * GraphQL variables
     */
    variables?: typeof arg1 extends undefined ? VT : (typeof arg1 & {
        value: T;
        variables: VT;
    })['variables'];
    /**
     * Override the GraphQL path
     *
     * (default is `'/graphql'`)
     */
    graphqlPath?: string;
}): Omit<{
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: any;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: any, callback?: ((data: any, fetcher: ImperativeFetch) => void) | undefined) => any;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: FetchConfigType<any, any>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: any;
        id?: any;
        url?: string | undefined;
        default?: any;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: any, res?: Response | undefined) => void) | undefined;
        cacheProvider?: import("../types").CacheStoreType | undefined;
        onMutate?: ((data: any, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined;
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<any>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: any) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<any>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
}, "data"> & {
    data: {
        data: T;
        errors: any[];
        variables: VT;
    };
};
/**
 * Use an imperative version of the fetcher (similarly to Axios, it returns an object with `get`, `post`, etc)
 */
export declare function useImperative(): ImperativeFetch;
