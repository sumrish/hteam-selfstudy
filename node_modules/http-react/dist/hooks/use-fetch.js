'use client';
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFetch = void 0;
var React = __importStar(require("react"));
var react_1 = require("react");
var internal_1 = require("../internal");
var constants_1 = require("../internal/constants");
var utils_1 = require("../utils");
var shared_1 = require("../utils/shared");
/**
 * Passing `undefined` to `new Date()` returns `Invalid Date {}`, so return null instead
 */
var getDateIfValid = function (d) {
    // @ts-ignore - Evals to a Date
    return (((d === null || d === void 0 ? void 0 : d.toString()) === 'Invalid Date' || d === null ? null : d));
};
/**
 * Fetch hook
 */
function useFetch(init, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var ctx = (0, internal_1.useHRFContext)();
    var isRequest = init instanceof Object && (init === null || init === void 0 ? void 0 : init.json);
    var optionsConfig = typeof init === 'string'
        ? __assign({ 
            // Pass init as the url if init is a string
            url: init }, options) : isRequest
        ? __assign({ url: init.url, method: init.method, init: init }, options) : init;
    var _o = optionsConfig.onOnline, onOnline = _o === void 0 ? ctx.onOnline : _o, _p = optionsConfig.onOffline, onOffline = _p === void 0 ? ctx.onOffline : _p, onMutate = optionsConfig.onMutate, _q = optionsConfig.revalidateOnMount, revalidateOnMount = _q === void 0 ? ctx.revalidateOnMount : _q, _r = optionsConfig.url, url = _r === void 0 ? '' : _r, _s = optionsConfig.query, query = _s === void 0 ? {} : _s, _t = optionsConfig.params, params = _t === void 0 ? {} : _t, _u = optionsConfig.baseUrl, baseUrl = _u === void 0 ? undefined : _u, _v = optionsConfig.method, method = _v === void 0 ? isRequest ? init.method : constants_1.METHODS.GET : _v, _w = optionsConfig.headers, headers = _w === void 0 ? {} : _w, _x = optionsConfig.body, body = _x === void 0 ? undefined : _x, _y = optionsConfig.formatBody, formatBody = _y === void 0 ? function (e) { return JSON.stringify(e); } : _y, _z = optionsConfig.resolver, resolver = _z === void 0 ? (0, shared_1.isFunction)(ctx.resolver) ? ctx.resolver : constants_1.DEFAULT_RESOLVER : _z, onError = optionsConfig.onError, _0 = optionsConfig.auto, auto = _0 === void 0 ? (0, shared_1.isDefined)(ctx.auto) ? ctx.auto : true : _0, _1 = optionsConfig.memory, memory = _1 === void 0 ? (0, shared_1.isDefined)(ctx.memory) ? ctx.memory : true : _1, onResolve = optionsConfig.onResolve, onAbort = optionsConfig.onAbort, _2 = optionsConfig.refresh, refresh = _2 === void 0 ? (0, shared_1.isDefined)(ctx.refresh) ? ctx.refresh : 0 : _2, _3 = optionsConfig.attempts, attempts = _3 === void 0 ? ctx.attempts : _3, _4 = optionsConfig.attemptInterval, attemptInterval = _4 === void 0 ? ctx.attemptInterval : _4, _5 = optionsConfig.revalidateOnFocus, revalidateOnFocus = _5 === void 0 ? ctx.revalidateOnFocus : _5, $suspense = optionsConfig.suspense, _6 = optionsConfig.onFetchStart, onFetchStart = _6 === void 0 ? ctx.onFetchStart : _6, _7 = optionsConfig.onFetchEnd, onFetchEnd = _7 === void 0 ? ctx.onFetchEnd : _7, _8 = optionsConfig.cacheIfError, cacheIfError = _8 === void 0 ? ctx.cacheIfError : _8, _9 = optionsConfig.maxCacheAge, maxCacheAge = _9 === void 0 ? ctx.maxCacheAge : _9, _10 = optionsConfig.fetcher, fetcher = _10 === void 0 ? ctx.fetcher : _10;
    var $fetch = (0, shared_1.isFunction)(fetcher) ? fetcher : fetch;
    var config = {
        query: query,
        params: params,
        baseUrl: baseUrl,
        method: method,
        headers: headers,
        body: body,
        formatBody: formatBody
    };
    var _11 = ctx.cacheProvider, $cacheProvider = _11 === void 0 ? internal_1.defaultCache : _11;
    var logStart = (0, shared_1.isFunction)(onFetchStart);
    var logEnd = (0, shared_1.isFunction)(onFetchEnd);
    var _12 = optionsConfig.cacheProvider, cacheProvider = _12 === void 0 ? $cacheProvider : _12;
    var requestCallId = React.useMemo(function () { return "".concat(Math.random()).split('.')[1]; }, []);
    var willResolve = (0, shared_1.isDefined)(onResolve);
    var handleError = (0, shared_1.isDefined)(onError);
    var handleOnAbort = (0, shared_1.isDefined)(onAbort);
    var handleMutate = (0, shared_1.isDefined)(onMutate);
    var handleOnline = (0, shared_1.isDefined)(onOnline);
    var handleOffline = (0, shared_1.isDefined)(onOffline);
    var retryOnReconnect = optionsConfig.auto === false
        ? false
        : (0, shared_1.isDefined)(optionsConfig.retryOnReconnect)
            ? optionsConfig.retryOnReconnect
            : ctx.retryOnReconnect;
    var reqQuery = __assign(__assign({}, ctx.query), config.query);
    var reqParams = __assign(__assign({}, ctx.params), config.params);
    var rawUrl = ((0, shared_1.hasBaseUrl)(url)
        ? ''
        : !(0, shared_1.isDefined)(config.baseUrl)
            ? !(0, shared_1.isDefined)(ctx.baseUrl)
                ? ''
                : ctx.baseUrl
            : config.baseUrl) + url;
    var defaultId = [method, url].join(' ');
    var _13 = optionsConfig.id, id = _13 === void 0 ? defaultId : _13;
    var idString = (0, shared_1.serialize)(id);
    var urlWithParams = React.useMemo(function () { return (0, shared_1.setURLParams)(rawUrl, reqParams); }, [(0, shared_1.serialize)(reqParams), config.baseUrl, ctx.baseUrl, url]);
    var resolvedKey = (0, shared_1.serialize)({ idString: idString });
    var resolvedDataKey = (0, shared_1.serialize)({ idString: idString, reqQuery: reqQuery, reqParams: reqParams });
    var ageKey = ['max-age', resolvedDataKey].join('-');
    var paginationCache = cacheProvider.get(resolvedDataKey);
    var normalCache = cacheProvider.get(resolvedKey);
    var maxAge = (0, utils_1.getMiliseconds)(maxCacheAge || '0 ms');
    // Revalidates if passed maxCacheAge has changed
    if (!cacheProvider.get('maxAgeValue' + resolvedDataKey)) {
        cacheProvider.set('maxAgeValue' + resolvedDataKey, maxCacheAge || '0 ms');
    }
    else {
        if (cacheProvider.get('maxAgeValue' + resolvedDataKey) !== maxCacheAge) {
            cacheProvider.set(ageKey, 0);
            cacheProvider.set('maxAgeValue' + resolvedDataKey, maxCacheAge);
        }
    }
    if (!(0, shared_1.isDefined)(cacheProvider.get(ageKey)) ||
        !(0, shared_1.notNull)(cacheProvider.get(ageKey))) {
        cacheProvider.set(ageKey, maxAge);
    }
    var isExpired = Date.now() > cacheProvider.get(ageKey);
    var debounce = optionsConfig.debounce
        ? (0, utils_1.getMiliseconds)(optionsConfig.debounce)
        : 0;
    var canRevalidate = auto && isExpired;
    var suspense = $suspense || internal_1.willSuspend[resolvedKey];
    if (!suspense) {
        if (url !== '') {
            internal_1.suspenseInitialized[resolvedKey] = true;
        }
    }
    if (suspense && !internal_1.willSuspend[resolvedKey]) {
        if (!internal_1.suspenseInitialized[resolvedKey]) {
            internal_1.willSuspend[resolvedKey] = true;
        }
    }
    var realUrl = urlWithParams +
        (urlWithParams.includes('?') ? ((optionsConfig === null || optionsConfig === void 0 ? void 0 : optionsConfig.query) ? "&" : '') : '?');
    if (!(0, shared_1.isDefined)(internal_1.previousProps[resolvedKey])) {
        if (url !== '') {
            internal_1.previousProps[resolvedKey] = optionsConfig;
        }
    }
    var configUrl = internal_1.urls[resolvedKey] || {
        realUrl: realUrl,
        rawUrl: rawUrl
    };
    var stringDeps = (0, shared_1.serialize)(Object.assign({}, ctx, config === null || config === void 0 ? void 0 : config.headers, { method: config === null || config === void 0 ? void 0 : config.method }, config === null || config === void 0 ? void 0 : config.body, config === null || config === void 0 ? void 0 : config.query, config === null || config === void 0 ? void 0 : config.params, { resolver: undefined }, { reqQuery: reqQuery }, { reqParams: reqParams }));
    // This helps pass default values to other useFetch calls using the same id
    (0, react_1.useEffect)(function () {
        if ((0, shared_1.isDefined)(optionsConfig.default)) {
            if (!(0, shared_1.isDefined)(internal_1.fetcherDefaults[resolvedKey])) {
                if (url !== '') {
                    if (!(0, shared_1.isDefined)(cacheProvider.get(resolvedDataKey))) {
                        internal_1.fetcherDefaults[resolvedKey] = optionsConfig.default;
                    }
                }
                else {
                    if (!(0, shared_1.isDefined)(cacheProvider.get(resolvedDataKey))) {
                        internal_1.requestsProvider.emit(resolvedKey, {
                            requestCallId: requestCallId,
                            data: optionsConfig.default
                        });
                    }
                }
            }
        }
        else {
            if ((0, shared_1.isDefined)(internal_1.fetcherDefaults[resolvedKey])) {
                if (!(0, shared_1.isDefined)(cacheProvider.get(resolvedDataKey))) {
                    setData(internal_1.fetcherDefaults[resolvedKey]);
                }
            }
        }
    }, [resolvedKey]);
    var def = (_a = optionsConfig === null || optionsConfig === void 0 ? void 0 : optionsConfig.default) !== null && _a !== void 0 ? _a : internal_1.fetcherDefaults[resolvedKey];
    (0, react_1.useEffect)(function () {
        if (!canRevalidate) {
            internal_1.runningRequests[resolvedKey] = false;
        }
    }, []);
    var requestCache = cacheProvider.get(resolvedDataKey);
    var initialDataValue = (_c = (_b = internal_1.valuesMemory[resolvedKey]) !== null && _b !== void 0 ? _b : requestCache) !== null && _c !== void 0 ? _c : def;
    var _14 = (0, react_1.useState)({
        data: initialDataValue,
        online: true,
        loading: auto
            ? (0, internal_1.isPending)(resolvedKey) ||
                (revalidateOnMount
                    ? internal_1.previousConfig[resolvedKey] !== (0, shared_1.serialize)(optionsConfig)
                    : internal_1.previousConfig[resolvedKey] !== (0, shared_1.serialize)(optionsConfig))
            : false,
        error: (internal_1.hasErrors[resolvedDataKey] || false),
        completedAttempts: 0
    }), fetchState = _14[0], setFetchState = _14[1];
    var thisDeps = React.useRef({
        data: false,
        online: false,
        loading: false,
        error: false,
        completedAttempts: false
    }).current;
    var inDeps = function (k) {
        return thisDeps[k];
    };
    var data = fetchState.data, loading = fetchState.loading, online = fetchState.online, error = fetchState.error, completedAttempts = fetchState.completedAttempts;
    var isLoading = isExpired ? (0, internal_1.isPending)(resolvedKey) || loading : false;
    var loadingFirst = !(internal_1.hasData[resolvedDataKey] || internal_1.hasData[resolvedKey]) && isLoading;
    if (!isExpired) {
        if (error) {
            setError(false);
        }
    }
    function setData(v) {
        setFetchState(function (p) {
            if ((0, shared_1.isFunction)(v)) {
                var newVal = v(p.data);
                if (!(0, shared_1.jsonCompare)(p.data, newVal)) {
                    return __assign(__assign({}, p), { data: newVal });
                }
            }
            else {
                if (!(0, shared_1.jsonCompare)(p.data, v)) {
                    return __assign(__assign({}, p), { data: v });
                }
            }
            return p;
        });
    }
    var thisCache = (_f = (_e = (_d = paginationCache !== null && paginationCache !== void 0 ? paginationCache : normalCache) !== null && _d !== void 0 ? _d : data) !== null && _e !== void 0 ? _e : def) !== null && _f !== void 0 ? _f : null;
    // Used JSON as deppendency instead of directly using a reference to data
    var rawJSON = (0, shared_1.serialize)(data);
    function setOnline(v) {
        setFetchState(function (p) {
            if (online !== p.online) {
                return __assign(__assign({}, p), { online: v });
            }
            return p;
        });
    }
    var requestHeaders = __assign(__assign({}, ctx.headers), config.headers);
    function setError(v) {
        setFetchState(function (p) {
            if ((0, shared_1.isFunction)(v)) {
                var newErroValue = v(p.error);
                if (newErroValue !== p.error) {
                    return __assign(__assign({}, p), { error: newErroValue });
                }
            }
            else {
                if (v !== p.error) {
                    return __assign(__assign({}, p), { error: v });
                }
            }
            return p;
        });
    }
    function setLoading(v) {
        setFetchState(function (p) {
            if ((0, shared_1.isFunction)(v)) {
                var newLoadingValue = v(p.loading);
                if (newLoadingValue !== p.loading) {
                    return __assign(__assign({}, p), { loading: newLoadingValue });
                }
            }
            else {
                if (v !== p.loading) {
                    return __assign(__assign({}, p), { loading: v });
                }
            }
            return p;
        });
    }
    function setCompletedAttempts(v) {
        setFetchState(function (p) {
            if ((0, shared_1.isFunction)(v)) {
                var newCompletedAttempts = v(p.completedAttempts);
                if (newCompletedAttempts !== p.completedAttempts) {
                    return __assign(__assign({}, p), { completedAttempts: newCompletedAttempts });
                }
            }
            else {
                if (v !== p.completedAttempts) {
                    return __assign(__assign({}, p), { completedAttempts: v });
                }
            }
            return p;
        });
    }
    var requestAbortController = (_g = internal_1.abortControllers[resolvedKey]) !== null && _g !== void 0 ? _g : new AbortController();
    var isGqlRequest = (0, shared_1.isDefined)(optionsConfig['__gql']);
    var fetchData = React.useCallback(function fetchData(c) {
        var _a;
        if (c === void 0) { c = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var rawUrl, urlWithParams, realUrl, newAbortController_1, $$data_1, $$error, $$response, $$code, $$loading, $$completedAttempts, rpc_1, reqConfig, _headers, k, newRequestConfig, r, json, resolvedDate, code, _data_1, _b, dataExpirationTime, __data_1, err_1, errorString;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        rawUrl = ((0, shared_1.hasBaseUrl)(url)
                            ? ''
                            : !(0, shared_1.isDefined)(config.baseUrl)
                                ? !(0, shared_1.isDefined)(ctx.baseUrl)
                                    ? ''
                                    : ctx.baseUrl
                                : config.baseUrl) + url;
                        urlWithParams = (0, shared_1.setURLParams)(rawUrl, c.params);
                        realUrl = urlWithParams +
                            (urlWithParams.includes('?') ? ((c === null || c === void 0 ? void 0 : c.query) !== '' ? "&" : '') : '?');
                        if (!(internal_1.previousConfig[resolvedKey] !== (0, shared_1.serialize)(optionsConfig))) return [3 /*break*/, 8];
                        internal_1.previousProps[resolvedKey] = optionsConfig;
                        (0, shared_1.queue)(function () {
                            if (url !== '') {
                                var newUrls = {
                                    realUrl: realUrl,
                                    rawUrl: rawUrl
                                };
                                internal_1.urls[resolvedKey] = newUrls;
                            }
                        });
                        if (!!(0, internal_1.isPending)(resolvedKey)) return [3 /*break*/, 8];
                        internal_1.runningRequests[resolvedKey] = auto;
                        internal_1.hasErrors[resolvedDataKey] = false;
                        internal_1.hasErrors[resolvedKey] = false;
                        internal_1.resolvedOnErrorCalls[resolvedKey] = false;
                        internal_1.resolvedHookCalls[resolvedKey] = false;
                        internal_1.previousConfig[resolvedKey] = (0, shared_1.serialize)(optionsConfig);
                        newAbortController_1 = new AbortController();
                        cacheProvider.set(ageKey, Date.now() - 1);
                        internal_1.requestsProvider.emit(resolvedKey, {
                            requestCallId: loadingFirst ? requestCallId : undefined,
                            loading: true,
                            requestAbortController: newAbortController_1,
                            error: false
                        });
                        internal_1.abortControllers[resolvedKey] = newAbortController_1;
                        $$error = false;
                        $$response = void 0;
                        $$code = void 0;
                        $$loading = void 0;
                        $$completedAttempts = void 0;
                        rpc_1 = {};
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 6, 7, 8]);
                        reqConfig = {};
                        _headers = isRequest ? (0, shared_1.getRequestHeaders)(init) : {};
                        if (isRequest) {
                            for (k in init) {
                                // @ts-ignore Getting keys from Request init
                                reqConfig[k] = init[k];
                            }
                        }
                        cacheProvider.set('requestStart' + resolvedDataKey, Date.now());
                        internal_1.requestInitialTimes[resolvedDataKey] = Date.now();
                        newRequestConfig = (isRequest
                            ? __assign(__assign(__assign(__assign({}, ctx), reqConfig), optionsConfig), { signal: (function () {
                                    return newAbortController_1.signal;
                                })(), headers: __assign(__assign(__assign(__assign({ 'Content-Type': 'application/json' }, ctx.headers), _headers), config.headers), c.headers) }) : __assign(__assign(__assign({}, ctx), optionsConfig), { signal: (function () {
                                return newAbortController_1.signal;
                            })(), body: (0, shared_1.isFunction)(formatBody)
                                ? // @ts-ignore // If formatBody is a function
                                    formatBody(optionsConfig === null || optionsConfig === void 0 ? void 0 : optionsConfig.body)
                                : optionsConfig === null || optionsConfig === void 0 ? void 0 : optionsConfig.body, headers: __assign(__assign(__assign({ 'Content-Type': 'application/json' }, ctx.headers), config.headers), c.headers) }));
                        r = new Request(realUrl + c.query, newRequestConfig);
                        if (logStart) {
                            ;
                            onFetchStart(r, optionsConfig, ctx);
                        }
                        return [4 /*yield*/, $fetch(r.url, newRequestConfig)];
                    case 2:
                        json = _c.sent();
                        resolvedDate = Date.now();
                        cacheProvider.set('expiration' + resolvedDataKey, resolvedDate + maxAge);
                        cacheProvider.set('requestEnds' + resolvedDataKey, resolvedDate);
                        internal_1.requestResponseTimes[resolvedDataKey] =
                            (0, utils_1.getTimePassed)(resolvedDataKey);
                        internal_1.lastResponses[resolvedKey] = json;
                        code = json.status;
                        internal_1.statusCodes[resolvedKey] = code;
                        $$error = false;
                        rpc_1 = __assign(__assign({}, rpc_1), { response: json, error: false, code: code });
                        if (!((_a = json === null || json === void 0 ? void 0 : json['data']) !== null && _a !== void 0)) return [3 /*break*/, 3];
                        _b = _a;
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, resolver(json)];
                    case 4:
                        _b = (_c.sent());
                        _c.label = 5;
                    case 5:
                        _data_1 = _b;
                        if (code >= 200 && code < 400) {
                            internal_1.hasData[resolvedDataKey] = true;
                            internal_1.hasData[resolvedKey] = true;
                            rpc_1 = __assign(__assign({}, rpc_1), { error: false });
                            dataExpirationTime = Date.now() + maxAge;
                            cacheProvider.set(ageKey, dataExpirationTime);
                            __data_1 = isGqlRequest
                                ? __assign(__assign({}, _data_1), { variables: optionsConfig === null || optionsConfig === void 0 ? void 0 : optionsConfig.variables, errors: (_data_1 === null || _data_1 === void 0 ? void 0 : _data_1.errors) ? _data_1.errors : undefined }) : _data_1;
                            if ((_data_1 === null || _data_1 === void 0 ? void 0 : _data_1.errors) && isGqlRequest) {
                                $$error = true;
                                internal_1.hasErrors[resolvedDataKey] = true;
                                internal_1.hasErrors[resolvedKey] = true;
                                rpc_1 = __assign(__assign({}, rpc_1), { error: true });
                                if (handleError) {
                                    if (!internal_1.resolvedOnErrorCalls[resolvedKey]) {
                                        internal_1.resolvedOnErrorCalls[resolvedKey] = true;
                                        onError(true);
                                    }
                                }
                            }
                            cacheProvider.set(resolvedDataKey, __data_1);
                            cacheProvider.set(resolvedKey, __data_1);
                            internal_1.valuesMemory[resolvedKey] = __data_1;
                            rpc_1 = __assign(__assign({}, rpc_1), { data: __data_1, isResolved: true, loading: false, variables: isGqlRequest
                                    ? (optionsConfig === null || optionsConfig === void 0 ? void 0 : optionsConfig.variables) || {}
                                    : undefined, completedAttempts: 0 });
                            $$data_1 = __data_1;
                            internal_1.cacheForMutation[idString] = __data_1;
                            if (!(_data_1 === null || _data_1 === void 0 ? void 0 : _data_1.errors) && isGqlRequest) {
                                rpc_1 = __assign(__assign({}, rpc_1), { error: false });
                                $$error = false;
                                internal_1.hasErrors[resolvedDataKey] = false;
                                internal_1.hasErrors[resolvedKey] = false;
                            }
                            $$loading = false;
                            if (willResolve) {
                                if (!internal_1.resolvedHookCalls[resolvedKey]) {
                                    ;
                                    onResolve(__data_1, internal_1.lastResponses[resolvedKey]);
                                    internal_1.resolvedHookCalls[resolvedKey] = true;
                                }
                            }
                            internal_1.runningRequests[resolvedKey] = false;
                            // If a request completes succesfuly, reset the error attempts to 0
                            $$completedAttempts = 0;
                            (0, shared_1.queue)(function () {
                                internal_1.cacheForMutation[resolvedKey] = __data_1;
                            });
                        }
                        else {
                            rpc_1 = __assign(__assign({}, rpc_1), { error: true });
                            if (!cacheIfError) {
                                internal_1.hasData[resolvedDataKey] = false;
                                internal_1.hasData[resolvedKey] = false;
                            }
                            if (_data_1.errors && isGqlRequest) {
                                if (!cacheIfError) {
                                    internal_1.hasData[resolvedDataKey] = false;
                                    internal_1.hasData[resolvedKey] = false;
                                }
                                setFetchState(function (previous) {
                                    var newData = __assign(__assign({}, previous), { variables: optionsConfig === null || optionsConfig === void 0 ? void 0 : optionsConfig.variables, errors: _data_1.errors });
                                    $$data_1 = newData;
                                    internal_1.cacheForMutation[idString] = newData;
                                    rpc_1 = __assign(__assign({}, rpc_1), { data: newData, error: true });
                                    cacheProvider.set(resolvedDataKey, newData);
                                    cacheProvider.set(resolvedKey, newData);
                                    return previous;
                                });
                                if (handleError) {
                                    if (!internal_1.resolvedOnErrorCalls[resolvedKey]) {
                                        internal_1.resolvedOnErrorCalls[resolvedKey] = true;
                                        onError(true, json);
                                    }
                                }
                            }
                            else {
                                if (def) {
                                    $$data_1 = thisCache;
                                    internal_1.cacheForMutation[idString] = def;
                                    rpc_1 = __assign(__assign({}, rpc_1), { data: def });
                                }
                                if (handleError) {
                                    if (!internal_1.resolvedOnErrorCalls[resolvedKey]) {
                                        internal_1.resolvedOnErrorCalls[resolvedKey] = true;
                                        onError(_data_1, json);
                                    }
                                }
                            }
                            $$error = true;
                            internal_1.hasErrors[resolvedDataKey] = true;
                            internal_1.hasErrors[resolvedKey] = true;
                            internal_1.runningRequests[resolvedKey] = false;
                        }
                        if (logEnd) {
                            ;
                            onFetchEnd(internal_1.lastResponses[resolvedKey], optionsConfig, ctx);
                        }
                        return [3 /*break*/, 8];
                    case 6:
                        err_1 = _c.sent();
                        errorString = err_1 === null || err_1 === void 0 ? void 0 : err_1.toString();
                        // Only set error if no abort
                        if (!/abort/i.test(errorString)) {
                            if (!cacheIfError) {
                                internal_1.hasData[resolvedDataKey] = false;
                                internal_1.hasData[resolvedKey] = false;
                            }
                            rpc_1 = __assign(__assign({}, rpc_1), { error: true });
                            if (cacheIfError) {
                                if ((0, shared_1.notNull)(thisCache) && (0, shared_1.isDefined)(thisCache)) {
                                    $$data_1 = thisCache;
                                    internal_1.cacheForMutation[idString] = thisCache;
                                    rpc_1 = __assign(__assign({}, rpc_1), { data: thisCache });
                                }
                            }
                            else {
                                $$data_1 = def;
                                rpc_1 = __assign(__assign({}, rpc_1), { data: def });
                                internal_1.cacheForMutation[idString] = def;
                            }
                            $$error = true;
                            rpc_1 = __assign(__assign({}, rpc_1), { error: true });
                            internal_1.hasErrors[resolvedDataKey] = true;
                            internal_1.hasErrors[resolvedKey] = true;
                            if (handleError) {
                                if (!internal_1.resolvedOnErrorCalls[resolvedKey]) {
                                    internal_1.resolvedOnErrorCalls[resolvedKey] = true;
                                    onError(err_1);
                                }
                            }
                        }
                        else {
                            rpc_1 = __assign(__assign({}, rpc_1), { loading: true });
                            if (!(0, internal_1.isPending)(resolvedKey)) {
                                if (!(0, shared_1.isDefined)(cacheProvider.get(resolvedDataKey))) {
                                    if ((0, shared_1.isDefined)(def)) {
                                        $$data_1 = def;
                                        internal_1.cacheForMutation[idString] = def;
                                    }
                                    rpc_1 = __assign(__assign({}, rpc_1), { data: def, loading: true });
                                }
                            }
                        }
                        return [3 /*break*/, 8];
                    case 7:
                        internal_1.runningRequests[resolvedKey] = false;
                        internal_1.suspenseInitialized[resolvedKey] = true;
                        internal_1.requestsProvider.emit(resolvedKey, __assign(__assign({ error: internal_1.hasErrors[resolvedKey] || internal_1.hasErrors[resolvedDataKey] || false }, rpc_1), { loading: false }));
                        internal_1.willSuspend[resolvedKey] = false;
                        (0, shared_1.queue)(function () {
                            internal_1.canDebounce[resolvedKey] = true;
                        }, debounce);
                        return [2 /*return*/, $$data_1];
                    case 8: return [2 /*return*/];
                }
            });
        });
    }, [
        thisDeps,
        canRevalidate,
        ctx.auto,
        stringDeps,
        resolvedKey,
        config.method,
        (0, shared_1.serialize)(optionsConfig),
        realUrl,
        requestCallId,
        memory,
        def,
        loadingFirst
    ]);
    (0, react_1.useEffect)(function () {
        var signal = (requestAbortController || {}).signal;
        // Run onAbort callback
        var abortCallback = function () {
            if (loading) {
                if ((0, internal_1.isPending)(resolvedKey)) {
                    if (handleOnAbort) {
                        ;
                        onAbort();
                    }
                }
            }
        };
        signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', abortCallback);
        return function () {
            signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', abortCallback);
        };
    }, [requestAbortController, resolvedKey, onAbort, loading]);
    var imperativeFetch = React.useMemo(function () {
        var __headers = __assign(__assign({}, ctx.headers), config.headers);
        var __params = __assign(__assign({}, ctx.params), config.params);
        var __baseUrl = (0, shared_1.isDefined)(config.baseUrl) ? config.baseUrl : ctx.baseUrl;
        return (0, utils_1.createImperativeFetch)(__assign(__assign({}, ctx), { headers: __headers, baseUrl: __baseUrl, params: __params }));
    }, [(0, shared_1.serialize)(ctx)]);
    (0, react_1.useEffect)(function () {
        function waitFormUpdates(v) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, isMutating, $data, $error, online, loading, completedAttempts;
                return __generator(this, function (_b) {
                    _a = v || {}, isMutating = _a.isMutating, $data = _a.data, $error = _a.error, online = _a.online, loading = _a.loading, completedAttempts = _a.completedAttempts;
                    if (isMutating) {
                        if ((0, shared_1.serialize)($data) !== (0, shared_1.serialize)(internal_1.cacheForMutation[resolvedKey])) {
                            internal_1.cacheForMutation[idString] = data;
                            if (isMutating) {
                                if (handleMutate) {
                                    if (url === '') {
                                        ;
                                        onMutate($data, imperativeFetch);
                                    }
                                    else {
                                        if (!internal_1.runningMutate[resolvedKey]) {
                                            internal_1.runningMutate[resolvedKey] = true;
                                            onMutate($data, imperativeFetch);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (v.requestCallId !== requestCallId) {
                        if (!internal_1.willSuspend[resolvedKey]) {
                            (0, shared_1.queue)(function () {
                                if (inDeps('data')) {
                                    setData($data);
                                }
                                if (inDeps('online')) {
                                    setOnline(online);
                                }
                                if (inDeps('loading')) {
                                    setLoading(loading);
                                }
                                if (inDeps('error')) {
                                    setError($error);
                                }
                                if (inDeps('completedAttempts')) {
                                    setCompletedAttempts(completedAttempts);
                                }
                            });
                        }
                    }
                    return [2 /*return*/];
                });
            });
        }
        internal_1.requestsProvider.addListener(resolvedKey, waitFormUpdates);
        return function () {
            internal_1.requestsProvider.removeListener(resolvedKey, waitFormUpdates);
        };
    }, [
        thisDeps,
        JSON.stringify(optionsConfig),
        resolvedKey,
        resolvedDataKey,
        requestCallId,
        fetchState
    ]);
    var reValidate = React.useCallback(function reValidate() {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!(0, internal_1.isPending)(resolvedKey) && !loading) {
                    (0, utils_1.revalidate)(id);
                }
                return [2 /*return*/];
            });
        });
    }, [(0, shared_1.serialize)(id), loading]);
    (0, react_1.useEffect)(function () {
        function forceRefresh() {
            if (!(0, internal_1.isPending)(resolvedKey)) {
                // preventing revalidation where only need updates about
                // 'loading', 'error' and 'data' because the url can be ommited.
                if (url !== '') {
                    fetchData({
                        query: Object.keys(reqQuery)
                            .map(function (q) { return [q, reqQuery[q]].join('='); })
                            .join('&'),
                        params: reqParams
                    });
                }
            }
        }
        var idString = (0, shared_1.serialize)(id);
        internal_1.requestsProvider.addListener(idString, forceRefresh);
        return function () {
            internal_1.requestsProvider.removeListener(idString, forceRefresh);
        };
    }, [
        fetchState,
        resolvedKey,
        suspense,
        loading,
        requestCallId,
        stringDeps,
        canRevalidate,
        ctx.auto,
        idString,
        fetchState,
        id
    ]);
    (0, react_1.useEffect)(function () {
        function backOnline() {
            var willCancel = false;
            function cancelReconectionAttempt() {
                willCancel = true;
            }
            internal_1.requestsProvider.emit(resolvedKey, {
                requestCallId: requestCallId,
                online: true
            });
            setOnline(true);
            internal_1.offlineHandled[resolvedKey] = false;
            if (handleOnline) {
                if (!internal_1.onlineHandled[resolvedKey]) {
                    internal_1.onlineHandled[resolvedKey] = true;
                    onOnline({ cancel: cancelReconectionAttempt });
                }
            }
            if (!willCancel) {
                reValidate();
            }
        }
        function addOnlineListener() {
            if (shared_1.windowExists) {
                if ('addEventListener' in window) {
                    if (retryOnReconnect) {
                        window.addEventListener('online', backOnline);
                    }
                }
            }
        }
        addOnlineListener();
        return function () {
            if (shared_1.windowExists) {
                if ('addEventListener' in window) {
                    window.removeEventListener('online', backOnline);
                }
            }
        };
    }, [onOnline, reValidate, requestCallId, resolvedKey, retryOnReconnect]);
    (0, react_1.useEffect)(function () {
        function wentOffline() {
            internal_1.runningRequests[resolvedKey] = false;
            setOnline(false);
            internal_1.requestsProvider.emit(resolvedKey, {
                requestCallId: requestCallId,
                online: false
            });
            internal_1.onlineHandled[resolvedKey] = false;
            if (handleOffline) {
                if (!internal_1.offlineHandled[resolvedKey]) {
                    internal_1.offlineHandled[resolvedKey] = true;
                    onOffline();
                }
            }
        }
        function addOfflineListener() {
            if (shared_1.windowExists) {
                if ('addEventListener' in window) {
                    window.addEventListener('offline', wentOffline);
                }
            }
        }
        addOfflineListener();
        return function () {
            if (shared_1.windowExists) {
                if ('addEventListener' in window) {
                    window.removeEventListener('offline', wentOffline);
                }
            }
        };
    }, [onOffline, reValidate, requestCallId, resolvedKey, retryOnReconnect]);
    (0, react_1.useEffect)(function () {
        return function () {
            if (revalidateOnMount) {
                if (canRevalidate) {
                    if (url !== '') {
                        if (internal_1.suspenseInitialized[resolvedKey]) {
                            (0, shared_1.queue)(function () {
                                internal_1.previousConfig[resolvedKey] = undefined;
                                internal_1.hasErrors[resolvedKey] = false;
                                internal_1.hasErrors[resolvedDataKey] = false;
                                internal_1.runningRequests[resolvedKey] = false;
                                // Wait for 100ms after suspense unmount
                            }, 100);
                        }
                        else {
                            internal_1.previousConfig[resolvedKey] = undefined;
                            internal_1.hasErrors[resolvedKey] = false;
                            internal_1.hasErrors[resolvedDataKey] = false;
                            internal_1.runningRequests[resolvedKey] = false;
                        }
                    }
                }
            }
        };
    }, [requestCallId, resolvedKey, revalidateOnMount, suspense]);
    (0, react_1.useEffect)(function () {
        // Attempts will be made after a request fails
        if (attempts > 0) {
            var tm_1 = setTimeout(function () {
                if (error) {
                    if (completedAttempts < attempts) {
                        reValidate();
                        setCompletedAttempts(function (previousAttempts) {
                            var newAttemptsValue = previousAttempts + 1;
                            internal_1.requestsProvider.emit(resolvedKey, {
                                requestCallId: requestCallId,
                                completedAttempts: newAttemptsValue
                            });
                            return newAttemptsValue;
                        });
                    }
                    else if (completedAttempts === attempts) {
                        internal_1.requestsProvider.emit(resolvedKey, {
                            requestCallId: requestCallId,
                            online: false,
                            error: true
                        });
                        if (inDeps('online'))
                            setOnline(false);
                    }
                }
            }, (0, utils_1.getMiliseconds)(attemptInterval));
            return function () {
                clearTimeout(tm_1);
            };
        }
        return function () { };
    }, [error, attempts, rawJSON, attemptInterval, completedAttempts]);
    (0, react_1.useEffect)(function () {
        var refreshAmount = (0, utils_1.getMiliseconds)(refresh);
        if (completedAttempts === 0) {
            if (refreshAmount > 0 && canRevalidate) {
                var tm_2 = setTimeout(reValidate, refreshAmount);
                return function () {
                    clearTimeout(tm_2);
                };
            }
        }
        return function () { };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [refresh, loading, error, rawJSON, completedAttempts, config]);
    var initializeRevalidation = React.useCallback(function initializeRevalidation() {
        return __awaiter(this, void 0, void 0, function () {
            var d;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        d = undefined;
                        if (!canRevalidate) return [3 /*break*/, 4];
                        if (!(url !== '')) return [3 /*break*/, 2];
                        return [4 /*yield*/, fetchData({
                                query: Object.keys(reqQuery)
                                    .map(function (q) { return [q, reqQuery[q]].join('='); })
                                    .join('&'),
                                params: reqParams
                            })];
                    case 1:
                        d = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        d = def;
                        // It means a url is not passed
                        setFetchState(function (prev) { return (__assign(__assign({}, prev), { loading: false, error: internal_1.hasErrors[resolvedDataKey] || internal_1.hasErrors[resolvedKey], completedAttempts: prev.completedAttempts })); });
                        _a.label = 3;
                    case 3: return [3 /*break*/, 5];
                    case 4:
                        d = def;
                        _a.label = 5;
                    case 5: return [2 /*return*/, d];
                }
            });
        });
    }, [(0, shared_1.serialize)((0, shared_1.serialize)(optionsConfig)), fetchState, thisDeps]);
    if (!suspense) {
        if (url !== '') {
            internal_1.suspenseInitialized[resolvedKey] = true;
        }
    }
    (0, utils_1.useIsomorphicLayoutEffect)(function () {
        var _a;
        if (url !== '') {
            if (!(0, shared_1.jsonCompare)(internal_1.previousProps[resolvedKey], optionsConfig)) {
                (_a = internal_1.abortControllers[resolvedKey]) === null || _a === void 0 ? void 0 : _a.abort();
                if (inDeps('data')) {
                    (0, shared_1.queue)(initializeRevalidation);
                }
            }
        }
    }, [(0, shared_1.serialize)(optionsConfig), thisDeps]);
    if (suspense) {
        if (auto) {
            if (shared_1.windowExists) {
                if (!internal_1.suspenseInitialized[resolvedKey]) {
                    if (!internal_1.suspenseRevalidationStarted[resolvedKey]) {
                        internal_1.suspenseRevalidationStarted[resolvedKey] = initializeRevalidation();
                    }
                    throw internal_1.suspenseRevalidationStarted[resolvedKey];
                }
            }
            else {
                throw {
                    message: "Use 'SSRSuspense' instead of 'Suspense' when using SSR and suspense"
                };
            }
        }
    }
    (0, utils_1.useIsomorphicLayoutEffect)(function () {
        if (!internal_1.runningRequests[resolvedKey] && isExpired) {
            if (shared_1.windowExists) {
                if (canRevalidate && url !== '') {
                    if (!(0, shared_1.jsonCompare)(internal_1.previousConfig[resolvedKey], optionsConfig)) {
                        if (!(0, internal_1.isPending)(resolvedKey)) {
                            if (inDeps('data')) {
                                initializeRevalidation();
                            }
                        }
                        else {
                            setLoading(true);
                        }
                    }
                }
            }
        }
    }, [resolvedKey, (0, shared_1.serialize)(optionsConfig), canRevalidate, thisDeps]);
    (0, utils_1.useIsomorphicLayoutEffect)(function () {
        var revalidateAfterUnmount = revalidateOnMount
            ? true
            : internal_1.previousConfig[resolvedKey] !== (0, shared_1.serialize)(optionsConfig);
        function revalidate() {
            if (!debounce && !internal_1.canDebounce[resolvedKey]) {
                if (inDeps('data')) {
                    initializeRevalidation();
                }
            }
        }
        if (revalidateAfterUnmount) {
            if (suspense) {
                if (internal_1.suspenseInitialized[resolvedKey]) {
                    revalidate();
                }
            }
            else {
                revalidate();
            }
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [(0, shared_1.serialize)(optionsConfig), thisDeps]);
    (0, react_1.useEffect)(function () {
        function addFocusListener() {
            if (revalidateOnFocus && shared_1.windowExists) {
                if ('addEventListener' in window) {
                    window.addEventListener('focus', reValidate);
                }
            }
        }
        addFocusListener();
        return function () {
            if (shared_1.windowExists) {
                if ('addEventListener' in window) {
                    window.removeEventListener('focus', reValidate);
                }
            }
        };
    }, [
        requestCallId,
        url,
        revalidateOnFocus,
        stringDeps,
        loading,
        reValidate,
        refresh,
        (0, shared_1.serialize)(config)
    ]);
    var __config = __assign(__assign(__assign(__assign({}, config), optionsConfig), internal_1.previousProps[resolvedKey]), { params: __assign(__assign({}, reqParams), (_h = internal_1.previousProps[resolvedKey]) === null || _h === void 0 ? void 0 : _h.params), headers: __assign(__assign({}, requestHeaders), (_j = internal_1.previousProps[resolvedKey]) === null || _j === void 0 ? void 0 : _j.headers), body: config.body, baseUrl: ctx.baseUrl || config.baseUrl, url: (_k = configUrl === null || configUrl === void 0 ? void 0 : configUrl.realUrl) === null || _k === void 0 ? void 0 : _k.replace('?', ''), rawUrl: configUrl === null || configUrl === void 0 ? void 0 : configUrl.rawUrl, query: __assign(__assign({}, reqQuery), (_l = internal_1.previousProps[resolvedKey]) === null || _l === void 0 ? void 0 : _l.query) });
    function forceMutate(newValue, callback) {
        if (callback === void 0) { callback = function () { }; }
        if (!(0, shared_1.isFunction)(newValue)) {
            if ((0, shared_1.serialize)(cacheProvider.get(resolvedDataKey)) !== (0, shared_1.serialize)(newValue)) {
                callback(newValue, imperativeFetch);
                cacheProvider.set(resolvedDataKey, newValue);
                cacheProvider.set(resolvedKey, newValue);
                internal_1.valuesMemory[resolvedKey] = newValue;
                internal_1.cacheForMutation[idString] = newValue;
                internal_1.runningMutate[resolvedKey] = false;
                internal_1.requestsProvider.emit(resolvedKey, {
                    requestCallId: requestCallId,
                    isMutating: true,
                    data: newValue
                });
                setData(newValue);
            }
        }
        else {
            var newVal = newValue(data);
            if ((0, shared_1.serialize)(cacheProvider.get(resolvedDataKey)) !== (0, shared_1.serialize)(newVal)) {
                callback(newVal, imperativeFetch);
                cacheProvider.set(resolvedDataKey, newVal);
                cacheProvider.set(resolvedKey, newVal);
                internal_1.valuesMemory[resolvedKey] = newVal;
                internal_1.cacheForMutation[idString] = newVal;
                internal_1.runningMutate[resolvedKey] = false;
                internal_1.requestsProvider.emit(resolvedKey, {
                    requestCallId: requestCallId,
                    isMutating: true,
                    data: newVal
                });
                setData(newVal);
            }
        }
    }
    var _15 = [
        (0, shared_1.notNull)(cacheProvider.get('requestStart' + resolvedDataKey))
            ? new Date(cacheProvider.get('requestStart' + resolvedDataKey))
            : null,
        (0, shared_1.notNull)(cacheProvider.get('requestEnds' + resolvedDataKey))
            ? new Date(cacheProvider.get('requestEnds' + resolvedDataKey))
            : null
    ], $requestStart = _15[0], $requestEnd = _15[1];
    var expirationDate = error
        ? (0, shared_1.notNull)($requestEnd)
            ? $requestEnd
            : null
        : maxAge === 0
            ? null
            : (0, shared_1.notNull)(cacheProvider.get('expiration' + resolvedDataKey))
                ? new Date(cacheProvider.get('expiration' + resolvedDataKey))
                : null;
    var isFailed = internal_1.hasErrors[resolvedDataKey] || internal_1.hasErrors[resolvedKey] || error;
    var responseData = (_m = (error && isFailed ? (cacheIfError ? thisCache : null) : thisCache)) !== null && _m !== void 0 ? _m : def;
    var isSuccess = !isLoading && !isFailed;
    var oneRequestResolved = !loadingFirst &&
        (internal_1.hasData[resolvedDataKey] ||
            internal_1.hasData[resolvedKey] ||
            (cacheIfError ? (0, shared_1.isDefined)(responseData) && (0, shared_1.notNull)(responseData) : false));
    return {
        get revalidating() {
            thisDeps.loading = true;
            return oneRequestResolved && isLoading;
        },
        get hasData() {
            thisDeps.data = true;
            return oneRequestResolved;
        },
        get success() {
            thisDeps.loading = true;
            thisDeps.error = true;
            return isSuccess;
        },
        get loadingFirst() {
            thisDeps.loading = true;
            return loadingFirst;
        },
        get requestStart() {
            thisDeps.loading = true;
            return getDateIfValid($requestStart);
        },
        get requestEnd() {
            thisDeps.loading = true;
            return getDateIfValid($requestEnd);
        },
        get expiration() {
            thisDeps.loading = true;
            return getDateIfValid(isFailed ? null : expirationDate);
        },
        get responseTime() {
            var _a;
            thisDeps.loading = true;
            return (_a = internal_1.requestResponseTimes[resolvedDataKey]) !== null && _a !== void 0 ? _a : null;
        },
        get data() {
            thisDeps.data = true;
            return responseData;
        },
        get loading() {
            thisDeps.loading = true;
            return isLoading;
        },
        get error() {
            thisDeps.error = true;
            return isFailed || false;
        },
        get online() {
            thisDeps.online = true;
            return online;
        },
        get code() {
            thisDeps.loading = true;
            return internal_1.statusCodes[resolvedKey];
        },
        get reFetch() {
            thisDeps.loading = true;
            return reValidate;
        },
        get mutate() {
            thisDeps.data = true;
            return forceMutate;
        },
        get fetcher() {
            return imperativeFetch;
        },
        get abort() {
            return function () {
                var _a;
                (_a = internal_1.abortControllers[resolvedKey]) === null || _a === void 0 ? void 0 : _a.abort();
                if (loading) {
                    setError(false);
                    internal_1.hasErrors[resolvedDataKey] = false;
                    setLoading(false);
                    setData(requestCache);
                    internal_1.requestsProvider.emit(resolvedKey, {
                        requestCallId: requestCallId,
                        error: false,
                        loading: false,
                        data: requestCache
                    });
                }
            };
        },
        config: __config,
        get response() {
            thisDeps.loading = true;
            return internal_1.lastResponses[resolvedKey];
        },
        id: id,
        /**
         * The request key
         */
        key: resolvedKey
    };
}
exports.useFetch = useFetch;
useFetch.get = (0, shared_1.createRequestFn)('GET', '', {});
useFetch.delete = (0, shared_1.createRequestFn)('DELETE', '', {});
useFetch.head = (0, shared_1.createRequestFn)('HEAD', '', {});
useFetch.options = (0, shared_1.createRequestFn)('OPTIONS', '', {});
useFetch.post = (0, shared_1.createRequestFn)('POST', '', {});
useFetch.put = (0, shared_1.createRequestFn)('PUT', '', {});
useFetch.patch = (0, shared_1.createRequestFn)('PATCH', '', {});
useFetch.purge = (0, shared_1.createRequestFn)('PURGE', '', {});
useFetch.link = (0, shared_1.createRequestFn)('LINK', '', {});
useFetch.unlink = (0, shared_1.createRequestFn)('UNLINK', '', {});
useFetch.extend = utils_1.createImperativeFetch;
