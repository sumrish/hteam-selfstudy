import * as React from 'react';
import { CacheStoreType, FetchContextType, ImperativeFetch, FetchInit, TimeSpan } from '../types';
export declare function getMiliseconds(v: TimeSpan): number;
export declare function getTimePassed(key: any): number;
export declare const createImperativeFetch: (ctx: FetchContextType) => ImperativeFetch;
export declare const useIsomorphicLayoutEffect: typeof React.useEffect;
/**
 * Revalidate requests that match an id or ids
 */
export declare function revalidate(id: any | any[], __reval__?: boolean): void;
export declare function cancelRequest(id: any | any[]): void;
export declare function gql<T = any, VT = {
    [k: string]: any;
}>(...args: any): {
    value: T;
    variables: VT;
    baseUrl: string;
    graphqlPath: string;
    headers: {
        [key: string]: any;
    };
};
/**
 *
 * @param queries
 * @returns A hook that has full TypeScript support and offers autocomplete for every query passed
 */
export declare function queryProvider<R>(queries: {
    [e in keyof R]: R[e];
}, providerConfig?: {
    defaults?: {
        [key in keyof R]?: Partial<ReturnType<typeof gql<R[key]>>['value']>;
    };
    config?: {
        /**
         * The base url
         */
        baseUrl?: string;
        /**
         * Any aditional headers
         */
        headers?: {
            [key: string]: any;
        };
        /**
         * The caching mechanism
         */
        cacheProvider?: CacheStoreType;
    };
}): <P extends keyof R>(queryName: P, otherConfig?: (Omit<FetchInit<{ [e in keyof R]: R[e]; }[P] extends {
    value: unknown;
    variables: unknown;
    baseUrl: string;
    graphqlPath: string;
    headers: {
        [key: string]: any;
    };
} ? { [e in keyof R]: R[e]; }[P]["value"] : any, any>, "url"> & {
    default?: ({ [e in keyof R]: R[e]; }[P] extends {
        value: unknown;
        variables: unknown;
        baseUrl: string;
        graphqlPath: string;
        headers: {
            [key: string]: any;
        };
    } ? { [e in keyof R]: R[e]; }[P]["value"] : any) | undefined;
    variables?: ({ [e in keyof R]: R[e]; }[P] extends {
        value: unknown;
        variables: unknown;
        baseUrl: string;
        graphqlPath: string;
        headers: {
            [key: string]: any;
        };
    } ? { [e in keyof R]: R[e]; }[P]["variables"] : any) | undefined;
    graphqlPath?: string | undefined;
}) | undefined) => Omit<Omit<{
    hasData: boolean;
    revalidating: boolean;
    success: boolean;
    loadingFirst: boolean;
    expiration: Date;
    data: any;
    loading: boolean;
    error: Error | null;
    online: boolean;
    code: number;
    reFetch: () => Promise<void>;
    mutate: (update: any, callback?: ((data: any, fetcher: ImperativeFetch) => void) | undefined) => any;
    fetcher: ImperativeFetch;
    abort: () => void;
    config: Omit<RequestInit, "body" | "headers"> & {
        headers?: any;
        fetcher?(url: string, config: import("../types").FetchConfigType<any, any>): Promise<{
            json?: any;
            data?: any;
            status?: number | undefined;
            blob?: any;
            text?: any;
        }>;
        body?: any;
        id?: any;
        url?: string | undefined;
        default?: any;
        refresh?: TimeSpan | undefined;
        auto?: boolean | undefined;
        memory?: boolean | undefined;
        onResolve?: ((data: any, res?: Response | undefined) => void) | undefined;
        cacheProvider?: CacheStoreType | undefined;
        onMutate?: ((data: any, fetcher: ImperativeFetch) => void) | undefined;
        onError?: ((error: Error, req?: Response | undefined) => void) | undefined; /**
         * Any aditional headers
         */
        onAbort?: (() => void) | undefined;
        cancelOnChange?: boolean | undefined;
        resolver?: ((d: import("../types").CustomResponse<any>) => any) | undefined;
        attempts?: number | undefined;
        attemptInterval?: TimeSpan | undefined;
        revalidateOnFocus?: boolean | undefined;
        revalidateOnMount?: boolean | undefined;
        onOffline?: (() => void) | undefined;
        onOnline?: ((e: {
            cancel: () => void;
        }) => void) | undefined;
        retryOnReconnect?: boolean | undefined;
        suspense?: boolean | undefined;
        baseUrl?: string | undefined;
        method?: import("../types").HTTP_METHODS | undefined;
        query?: any;
        params?: any;
        formatBody?: boolean | ((b: any) => any) | undefined;
        debounce?: TimeSpan | undefined;
        onFetchStart?: ((req: Request, config: import("../types").FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        onFetchEnd?: ((res: Response, config: import("../types").FetchConfigType<any, any>, ctx: FetchContextType) => void) | undefined;
        cacheIfError?: boolean | undefined;
        maxCacheAge?: TimeSpan | undefined;
    } & {
        baseUrl: string;
        url: string;
        rawUrl: string;
    };
    response: import("../types").CustomResponse<any>;
    id: any;
    key: string;
    responseTime: number;
    requestStart: Date;
    requestEnd: Date;
}, "data"> & {
    data: {
        data: any;
        errors: any[];
        variables: {
            [k: string]: any;
        };
    };
}, "data"> & {
    data: {
        data: { [e in keyof R]: R[e]; }[P] extends {
            value: unknown;
            variables: unknown;
            baseUrl: string;
            graphqlPath: string;
            headers: {
                [key: string]: any;
            };
        } ? { [e in keyof R]: R[e]; }[P]["value"] : any;
        errors?: any[] | undefined;
        variables: { [e in keyof R]: R[e]; }[P] extends {
            value: unknown;
            variables: unknown;
            baseUrl: string;
            graphqlPath: string;
            headers: {
                [key: string]: any;
            };
        } ? { [e in keyof R]: R[e]; }[P]["variables"] : any;
    };
};
/**
 * Force mutation in requests from anywhere. This doesn't revalidate requests
 */
export declare function mutateData(...pairs: [any, any | ((cache: any) => any), boolean?][]): void;
